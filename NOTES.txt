// var drawLine = function(cellNum, edgeNum) {
//     //draw line from va to vb
//     var cell = angular.element('body').scope().this.diagram.cells[cellNum];
//     console.log('Cell', cell);
//     if (cell.name) {
//         console.log('Country name:', cell.name);
//     } else {
//         console.warn('Origin must be country!')
//             //invalid country, so pick a random one
//         while (!cell.name) {
//             var cell = angular.element('body').scope().this.diagram.cells[++cellNum];
//         }
//         console.log('Original cell did not work. Picked',cellNum,'instead')
//     }
//     if (!cell.halfedges[edgeNum] || !cell.halfedges[edgeNum].edge.va || !cell.halfedges[edgeNum].edge.vb) {
//         throw new Error('Cell is missing some info!')
//         return;
//     }
//     var ang = cell.halfedges[edgeNum].angle * 180 / Math.PI,
//         lin = document.createElement('div'),
//         dist = Math.sqrt(Math.pow((cell.halfedges[edgeNum].edge.va.x - cell.halfedges[edgeNum].edge.vb.x), 2) + Math.pow((cell.halfedges[edgeNum].edge.va.y - cell.halfedges[edgeNum].edge.vb.y), 2));
//     lin.style.transformOrigin = '0% 50%';
//     lin.style.width = dist + 'px';
//     lin.style.height = '4px';
//     lin.style.background = '#f00';
//     lin.style.position = 'absolute';
//     lin.style.left = cell.halfedges[edgeNum].edge.va.x + 'px';
//     lin.style.top = cell.halfedges[edgeNum].edge.va.y + 'px';
//     lin.style.transform = 'rotate(' + (ang - 90) + 'deg)';
//     lin.innerHTML = cell.name ? cell.name : 'OCEAN';
//     console.log('lin', lin)
//     $('body').append(lin);
//     //now, try to get both country names (if exist!)
//     var firstCoun = cell.name,
//         secondCoun = null;
//     secondCell = angular.element('body').scope().this.diagram.cells[angular.element('body').scope().this.cellByPoint(cell.halfedges[edgeNum].edge.rSite.x, cell.halfedges[edgeNum].edge.rSite.y)];
//     if (secondCell && secondCell.name) {
//         if (secondCell.name == firstCoun) {
//             //reverse countries!
//             secondCell = angular.element('body').scope().this.diagram.cells[angular.element('body').scope().this.cellByPoint(cell.halfedges[edgeNum].edge.lSite.x, cell.halfedges[edgeNum].edge.lSite.y)];
//         }
//         secondCoun = secondCell.name;
//     }
//     console.log('SECOND CELL', secondCell)
//     if (!secondCoun || secondCoun == null) {
//         console.log('Coastal country: ', firstCoun)
//     } else {
//         console.log('Border btwn', firstCoun, 'and', secondCoun)
//     }
//     console.log('2nd coun cell id', angular.element('body').scope().this.cellByPoint(cell.halfedges[edgeNum].edge.rSite.x, cell.halfedges[edgeNum].edge.rSite.y))
// }
var doCoords = false;
window.addEventListener('mousemove', function(e) {
    if (doCoords) console.log('X:', e.x, ',Y:', e.y)
})
window.addEventListener('mousedown', function(e) {
    if (!e.button || e.button == 0) {
        doCoords = true;
    }
})
window.addEventListener('mouseup', function(e) {
    if (!e.button || e.button == 0) {
        doCoords = false;
    }
})
this.getContinents = function(){
	for (var i=0;i<this.diagram.cells.length;i++){
		this.findNeighbors(i,true)
	}
	return this.allConts;
}
this.doneCouns = [], //if a country's in here, don't re-add it.
	this.currCont = [],
	this.allConts = [];

this.findNeighbors = function(c, mode) {
    if (mode) {
    	if(this.currCont && this.currCont.length) this.allConts.push(this.currCont);
        this.currCont = [];
    }
    m = false;
    var names = [this.diagram.cells[c].name];
    console.log('for cell', c, 'names starts as', names)
    if (!this.diagram.cells[c].name) {
        return;
    }
    if (this.doneCouns.indexOf(this.diagram.cells[c].name) > -1) {
        console.log('cell', this.diagram.cells[c].name, 'already recorded.', this.doneCouns);
        return names;
    }
    this.doneCouns.push(this.diagram.cells[c].name);
    this.currCont.push(this.diagram.cells[c].name)
        // for any cell with id c, find the neighbors. For each neighbor, find THAT cell's neighbors. If said neighbor is already in this.doneCouns, ignore
        //first, short-circuit if cell is already recorded;
    var kids = [];
    for (var i = 0; i < this.diagram.cells[c].halfedges.length; i++) {
        if (!this.diagram.cells[c].halfedges[i].edge.rSite || !this.diagram.cells[c].halfedges[i].edge.lSite) {
            //either left or right side is not defined. Cannot parse
            continue;
        }
        var neighborNum = this.cellByPoint(this.diagram.cells[c].halfedges[i].edge.rSite.x, this.diagram.cells[c].halfedges[i].edge.rSite.y);
        if (this.diagram.cells[neighborNum] && this.diagram.cells[c].name == this.diagram.cells[neighborNum].name) {
            //switch neighbor dir
            neighborNum = this.cellByPoint(this.diagram.cells[c].halfedges[i].edge.lSite.x, this.diagram.cells[c].halfedges[i].edge.lSite.y);
        }
        if (typeof neighborNum == 'undefined' || !this.diagram.cells[neighborNum]) {
            //for whatever reason, neighborNum is invalid
            continue;
        }
        if (this.diagram.cells[neighborNum].name && this.doneCouns.indexOf(this.diagram.cells[neighborNum].name) == -1) {
            kids.push(neighborNum)
        }
    }
    if (kids.length) {
        console.log('cell', c, 'has neighbors ("kids")', kids);
    } else {
        console.log('cell', c, 'has NO kids');
    }
    kids.forEach(function(k) {
        var naybz = this.findNeighbors(k);
        naybz.forEach(function(n) {
            if (this.doneCouns.indexOf(n) == -1) {
                names.push(n);
            }
        })
    })
    return names;
}
/*
TO DO: 
move name generation into initial cell generation, and separate name generation and placing. Will help when we create stuff to redraw in-progress map
write way to determine if cell A & B are neighbors (will be used for attacks.)
begin Mongo stuffs.
Move battle calculations to the BACK end for somewhat more secure game
RE-Add socket.io (for chat!)
Should user be able to do multiple games concordantly?

where do we actually want to store cell data? in game or map model? and how?
store 'blank' version of map in map, then store just army info in game?
need TWO separate load fns: 1 to load a blank map, 1 to load game-in-progress
put each active game as it's being played in its own socketio namespace:
socket.join(mapName),
io.to(mapName).emit(someEvent)
Will need to rewrite ALL of the fight routes (i.e., cell vs cell, etc.) to use socketio namespaces.

restructed game data:
(for any particular game)
var gameData = {
    mapId:123abc;//id of map used
    armies:[{
        user: dave,//user's name
        country: daveland,//country name
        num:4,//number (i.e., strength) of army
    }],//data for all cells that are countries.
    gameId:abcd3f6;//rando-generated id of game
}
use req.session for security! need to add that to most routes, and change socket.emit('getGames') to a regular http route!
*/